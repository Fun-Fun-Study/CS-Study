# 호이스팅(Hoisting)

> 코드가 실행하기 전, 변수선언/함수선언이 해당 스코프의 최상단으로 끌어 올려진 것과 같은 현상을 말한다.
>
> 끌어 올리다. 게양하다

## 실행 컨텍스트

> 실행 컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체이다.

- 자바스크립트 코드가 실행되는 환경
- 모든 자바스크립트 코드는 실행 컨텍스트 내부에서 실행된다.
- 함수를 실행하면 실행 컨텍스트가 생성되고, 콜 스택에 쌓이게 된다.

### 실행 컨텍스트의 구조

- 실행 컨텍스트는 렉시컬 환경(Lexical Environment)과 변수 환경(Variable Environment)로 구성
  #### 변수 환경
  - 현재 컨텍스트 내의 식별자들에 대한 정보, 외부 환경 정보를 담는다.
  - 스냅샷으로 변경 사항이 반영되지 않는다.
  #### 렉시컬 환경
  - 변수 환경을 복제하여 생성
  - 변경 사항이 반영된다.
  - **환경 레코드**
    - 함수 안의 식별자 정보를 저장
    - 환경 레코드를 생성하면서 **호이스팅 발생**
  - **외부 환경 참조**
    - 상위 스코프를 가리키는 참조
    - 현재 환경 레코드의 바깥에 있는 환경 레코드를 가리킨다.
  - **this 바인딩**
    - this 식별자가 가리키는 대상 객체
    - 실행 시점에 결정된다.

### 실행 컨텍스트 과정

- 자바스크립트 엔진은 코드를 실행하기 전 실행 가능한 코드를 형상화하고 구분하는 과정(실행 컨텍스트를 위한 과정)을 거친다.
- 자바스크립트 엔진은 코드를 실행하기 전 실행 컨텍스트를 위한 과정에서 모든 선언(var, let, const, function, class)을 **스코프에 등록**한다.
- 코드 실행 전 이미 **변수선언/함수선언**이 저장되어 있기 때문에 선언문보다 참조/호출이 먼저 나와도 오류없이 동작한다.
  - var 선언의 경우 오류없이 동작 <- 선언이 파일의 맨 위로 끌어올려진 것 처럼 보임

## 호이스팅이란

- 실행 컨텍스트 과정에서 선언이 코드의 실행보다 먼저 메모리에 저장되면서 생기는 현상
- 함수 내에서 필요한 값들을 위로 끌어올리는 것 처럼 보이는 현상
- 실제 코드가 끌어올려지는 것은 아니며 자바스크립트 Parser 내부적으로 끌어올려서 처리하는 것

### 변수 생성 단계

- 자바스크립트에서 변수은 3단계를 거쳐 생성된다.

1. 변수 선언 단계(Declaration phase)
   - 실행 컨텍스트의 변수 객체에 등록
2. 변수 초기화 단계(Initialization phase)
   - 등록된 변수의 메모리 공간이 생성
   - 변수를 undefined로 초기화
3. 변수 값 할당 단계(Assignment phase)
   - 변수에 사용자가 원하는 값을 할당

### 일시적 사각지대(Temporal Dead Zone)

- 변수 생성 단계에서 선언 단계와 초기화 단계 사이의 구간
- var로 선언한 변수는 선언단계와 초기화 단계가 한번에 이루어진다.
- let, const로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 일어난다.

### 변수 호이스팅

- 자바스크립의 모든 선언에는 호이스팅이 발생
- let, const, class 선언에는 **호이스팅이 발생하지 않는 것처럼 동작**
- let, const 선언은 변수 선언까지 **일시적 사각지대**에 의해 참조할 수 없게됨
  - 아직 초기화 되지 않아 메모리 공간이 없는 변수를 참조하려 하기 때문에 에러 발생
  ```javascript
  console.log(x); // undefined 출력
  console.log(y); // ReferenceError 발생
  var x = "a";
  let y = "b";
  ```

### 함수 호이스팅

- function 키워드로 선언된 함수(함수 선언문)는 함수로 호이스팅된다.
- 함수를 변수에 대입하는 경우(함수 표현식)에는 변수로 호이스팅되기 때문에 함수로 실행하려하면 ReferenceError 발생

  ```javascript
  fun1(); // Hello 출럭
  fun2(); // ReferenceError 출력

  function fun1() {
    console.log("Hello");
  }

  fun2 = function () {
    console.log("word");
  };
  ```
