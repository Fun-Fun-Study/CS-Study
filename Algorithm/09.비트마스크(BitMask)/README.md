# 🎢 비트마스크 (BitMask)

정수를 이진수로 표현하고, 비트 연산으로 다양한 문제를 해결해 나가는 기법

<br>

**예시**

- 열쇠를 가지고 있는 경우 / 가지고 있지 않은 경우
- 스위치를 키거나 끄는 경우
- 해당 위치에 방문 했거나 아직 방문하지 않은 경우

<br>

위와 같이 비트마스크는 이진수를 이용하여 1 또는 0 (True or False) 과 같이 두 가지 정보를 표현한다. <br>
비트마스크의 상태를 변경시키기 위한 다양한 연산을 비트연산으로 수행할 수 있다.

<br><br>

## 비트마스크를 사용하면?

1. 다른 자료 구조에 비해 수행 시간이 더 빠르다.

- bit연산이기 때문에 O(1)에 구현되는 것이 많기 때문에 다른 자료구조를 이용하는 것보다 훨씬 빠르게 동작한다.

2. 비트연산자를 사용하여 코드가 더 간결해진다.

3. 비트마스크를 사용하여 더 작은 메모리를 사용할 수 있다.

- 하나의 정수로 매우 많은 경우의 수를 표현할 수 있기 때문에 메모리 측면에서 효율적이며, 더 많은 데이터를 미리 계싼해서 저장해 둘 수 있는 장점이 있다.
- DP에 매우 유용하다.
- ex) bit가 10개인 경우에는 각 bit당 두 가지의 경우를 가지기 때문에 2^10가지의 경우를 10bit 이진수 하나로 표현할 수 있다.

<br><br>

## 비트마스크 연산자

- 비트 단위로 논리 연산을 할 때 사용하는 연산자

1. AND

   > "&" : 대응되는 비트가 모두 1이면 1을 반환 <br>
   > 1111 & 0101 = 0101

2. OR

   > "|" : 대응되는 비트 중에서 하나라도 1이면 1을 반환 <br>
   > 1111 & 0101 = 1111

3. XOR

   > "^" : 대응되는 비트가 서로 다르면 1을 반환 <br>
   > 1111 ^ 0101 = 1010

4. NOT

   > "~" : 비트가 1이면 0으로, 0이면 1로 반전시킴 <br>
   > ~1010 = 0101

5. SHIFT
   > "<<" : 지정한 수만큼 비트들을 왼쪽으로 이동 (이동되고 남은 비트는 0으로 채움) <br>
   > ">>" : 부호를 유지 하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동 <br>
   > 1010<<2 = 101000 <br>
   > 1010>>2 = 000010

<br><br>

## 비트마스크 집합

| 공집합 | 원소추가        | 원소삭제    | 원소의 포함 여부 확인 |
| ------ | --------------- | ----------- | --------------------- |
| A=0;   | A&#124;=(1<<n); | A&=~(1<<n); | if(A&(1<<n)==(1<<n)); |

<br><br>

## 백준 문제

[달이 차오른다 가자 (골드1)](https://www.acmicpc.net/problem/1194)
