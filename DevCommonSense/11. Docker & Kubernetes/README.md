# Docker

## Docker란?

#### Docker란 Go언어로 작성된 리눅스 컨테이너를 기반으로 하는 오픈소스 가상화 플랫폼

> 가상화란? 컴퓨터의 향상된 성능을 효율적으로 사용하기 위해 등장한 리소스 분리 사용 기술. 대표적으로 VM (OS 가상화)

- Docker는 내부적으로 리눅스의 LXC 라이브러리를 사용. LXC는 chroot, cgroup, namespace등 리눅스 API를 사용

<br>

### Docker의 특징

#### 안정성

- 기존에는 서버의 내용이나 설정의 변화를 직접 새로운 코드로 재배포함 (Mutable)
  - 여러 대의 서버를 명령어를 통해 계속 재배포하면 서버 환경이나 리소스 등의 차이로 완벽하게 동일한 서버가 아닐 가능성이 있음
- Docker는 배포된 이후 수정이 절대 불가능함(Immutable)
- 언제 누가 어떻게 변경했는지에 대한 관리를 할 필요가 없어 안정성이 높음

#### 확장성

- 더 많은 리소스가 필요하면 정확하게 동일한 서버를 배포할 수 있게 되어 확장성이 높음

#### 이식성

- 개발, 테스트, 운영 단계의 환경을 도커로 통일하고 언제 어디서든 도커만 설치돼있다면 컨테이너 실행이 가능해져 이식성이 높음

<br>

### Docker Container

> 컨테이너는 가상화 기술 중 하나로 격리된 공간에서 프로세스가 동작하는 기술. 대표적으로 리눅스 컨테이너

#### 가상화의 변동

1. 기존의 가상화 방식은 주로 OS를 가상화
   - 여러 가지 OS를 가상화 할 수 있고 사용법이 간단하지만 무겁고 느림
2. 이러한 상황을 개선하기 위해 CPU의 가상화 기술(HVM)을 이용한 KVM(Kernel-based Virtual Machine)과 반가상화 방식이 등장

   - 이러한 방식은 게스트 OS가 필요하긴 하지만, 전체 OS를 가상화하지 않음
   - 기존의 호스트형 가상화 방식에 비해 성능이 향상

3. 추가적인 OS를 설치하는 것은 어쨋든 성능 문제가 있었기 때문에 이를 위해 **프로세스 격리** 방식이 등장
   - 리눅스는 이 방식을 리눅스 **컨테이너**라고 하여 단순하게 프로세스를 격리시키기 때문에 가볍고 빠르게 동작
   - 컨테이너는 이러한 프로세스 격리 방식으로, CPU나 메모리를 딱 프로세스가 필요한 만큼만 추가로 사용하여 성능적으로 손실이 거의 없음
     <br><br>
     <img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/fdb7cd6c-e490-4406-92c3-d713f121ea90" style="width: 500">

#### Docker는, Host OS와 Docker Engine을 통해 Host의 커널을 모든 컨테이너가 공유

- 커널 공유를 통해 I/O 처리가 쉽고 성능의 효율이 높아짐

<br>

### Docker Image

#### 컨테이너를 실행할 수 있는 실행 파일, 설정 값 등을 가지고 있는 것으로 상태값을 가지지 않고 변하지 않음(Immutable)

> 컨테이너는 이미지를 실행한 상태라고 볼 수 있고, 추가되거나 변하는 값은 이미지가 아닌 컨테이너에 저장

#### Image의 생성 방식

<img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/cf273577-67a4-4c95-883b-8f823ba7e7cb" style="width: 500">

- Docker 이미지는 컨테이너를 실행하기 위한 모든 정보를 담고 있어 보통 용량이 수백MB
- 기존 이미지에 파일 하나를 추가했다고 다시 이미지를 다운로드 받는 건 매우 비효율적
- 따라서 레이어(Layer)라는 개념을 사용하여 여러 개의 레이어로 이미지를 구성

ex) Nginx 이미지를 만들기 위해서는 ubuntu 이미지를 베이스로 추가적인 nginx관련 레이어만 추가

<br>

### Dockerfile

#### 도커 이미지를 생성하기 위해 자체 문법 DSL (Domain Specific Language)를 통해 이미지 생성 과정을 정의

ex)<br>
<img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/052dcab8-9113-4902-9f64-0263a0b2d119" style="width: 500">

<br>

### Docker Hub

#### Docker 이미지를 저장하고 관리해주는 무료 저장소

- Docker로 소프트웨어를 배포하고 공개 이미지들을 공유

- Docker Hub처럼 공개된 방식이 아닌, 비공개 방식의 격리된 저장소인 `Docker Registry`도 존재

<br>
<br>

## Kubernetes

> Docker가 편리하다보니 많은 컨테이너를 운영하게 되고, 각각의 컨테이너 하나가 하나의 서버를 운영하는 것과 동일한 비용이 들게 됨

#### 컨테이너 유지보수 비용이 높아져 컨테이너를 따로 관리하는 것에 많은 제약이 붙게 되어 쉬운 관리를 위해 등장한 컨테이너 오케스트레이션 도구

<img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/a5d0098e-7dc5-4429-97bd-c26c84e40d0b" style="width: 600">

### Kubernetes 역할

- 여러 서버에 컨테이너를 분산해서 배치
- 문제가 생긴 컨테이너를 교체
- 컨테이너가 사용할 비밀번호나 환경 설정을 관리하고 주입

<br>

### Kubernete 기능

- 서비스 디스커버리와 로드밸런싱
  - DNS이름을 사용하거나 자체 IP주소를 사용하여 컨테이너를 노출시킬 수 있음
  - 트래픽이 많아지면, 자동으로 네트워크 트래픽을 로드밸런싱하여 배포가 안정적으로 이루어질 수 있게 함
- 스토리지 오케스트레이션
  - 로컬 저장소, 공용 클라우드 등과 같이 원하는 저장소 시스템을 자동으로 탑재 가능
- 자동화된 롤아웃과 롤백
  - 배포된 컨테이너의 원하는 상태를 서술(선언)할 수 있으며, 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있음
  - 장애 발생 시 애플리케이션의 롤백 지원
- 자동화된 빈 패킹
  - 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공
- 시크릿과 구성 관리
  - 시크릿과 애플리케이션 구성을 안전하게 배포하고 업데이트
  - 시크릿 정보들을 암호화하여 저장
- 자가 치유
  - 오류가 발생하거나 노드가 죽게 되면,컨테이너를 재시작 후 다시 스케쥴링
- 배치 실행
  - 배치(일괄 처리) 단위 작업을 실행할 수 있으며, 주기적인 배치 작업도 가능
- 오토 스케일링
  - 자동으로 애플리케이션의 스케일을 넓히거나 줄일 수 있음

<br>

### Kubertes 동작

#### 선언형 인터페이스와 Desired State

- 명령형 인터페이스가 아닌 선언형 인터페이스 사용
  - 어떤 동작을 지시하지 않고 원하는 상태를 선언
    ex) 우리 집 온도가 25도로 유지되면 좋겠다<br>
- 현재 상태와 선언된 상태가 일치하는지를 지속적으로 체크
- 쿠버네티스의 모든 것은
  Objects와 Controller 중심으로 동작<br>
  <img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/62cb8293-031d-46e5-97e9-3bd6ecd953c0" style="width: 500">
  - 클러스터의 상태를 나타내기 위해 Object이용(사용자의 의도를 담은 Record)
  - 주요 Objects로는 Pod, ReplicaSet, Deployments, Service, Volume
    - Pod : 쿠버네티스에서 배포할 수 있는 가장 작은 단위로, 한 개 이상의 컨테이너와 스토리지, 네트워크 속성을 가집니다. Pod에 속한 컨테이너는 스토리지와 네트워크를 공유하고, 서로 localhost로 접근할 수 있습니다.
    - ReplicaSet : Pod를 한 개 이상 복제하여 관리하는 Object
    - Service : 네트워크와 관련된 오브젝트. Pod를 외부 네트워크와 연결해주고, 여러 개의 Pod를 바라보는 내부 로드밸런서를 생성할 떄 사용
    - Volume : 저장소와 관련된 오브젝트. 호스트 디렉토리를 그대로 이용하거나 클라우드 스토리지를 동적으로 생성하여 사용

<br>

### Kubernetes 알아야할 점

#### Docker 지원 중단

- 구글에서 쿠버네티스를 제작
- 쿠버네티스는 컨테이너 런타임으로 도커를 지원했었음
- 쿠버네티스가 도커에 벤더락이 되지 않기 위해 어떤 컨테이너 런타임이든 사용 가능하게 하기 위한 일반화된 인터페이스 CRI(Container Runtime Interface)를 제작
- 쿠버네티스 1.24 버전 이상부터는 컨테이너를 돌릴 때 도커가 아닌, CRI를 준수한 컨테이너 런타임을 사용
- Docker 는 OCI를 준수하지 않기 때문에 쿠버네티스에서 런타임으로 사용 불가
- 단 런타임이 아니라, 도커에서 생성한 이미지 자체는 OCI(Open Container Initiative)를 준수하기 때문에 사용은 가능

#### 💡 한 줄 정리

- 쿠버네티스에서 컨테이너 런타임으로 도커 사용 불가능(cri-o, containered 등 다른 거 사용해야함)
- 도커에서 생성한 이미지 자체는 사용 가능. Dockerfile 써도 됨(OCI를 준수한 이미지라서)
