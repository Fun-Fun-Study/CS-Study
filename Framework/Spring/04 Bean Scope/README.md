# Spring Bean Scope

## Spring Bean이란?

- Spring IoC (Inversion of Control) 컨테이너에 의해 인스턴스화, 관리, 생성되는 객체

- Spring에서 ***POJO***를 beans 라고 함

- 우리가 컨테이너에 공급하는 설정 메타 데이터에 의해 생성됨

  > 💡 **POJO**란 Java로 생성하는 순수 객체. 객체 지향 원리에 충실하며 환경과 기술에 종속되지 않는 오브젝트
  
- Spring Bean Life Cycle
  - 일반적으로 **생성, 의존 설정, 초기화, 소멸**의 단계를 가짐

<br>

### Spring Bean Scope

<img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/da8644ff-65f2-4436-9c2a-29450828a410">
  
<br>

- 스프링은 기본적으로 모든 bean을 ***Singleton***으로 생성하여 관리
  - 애플리케이션 구동 시 JVM 안에서 스프링이 bean마다 하나의 객체를 생성
  - 따라서 스프링을 통해 주입받은 bean은 언제나 동일한 객체를 가리킴

- 스프링에서 ApplicationContext는 IoC Container임과 동시에 싱글톤을 저장하고 관리하는 Singleton Registry
  - 기본적으로 싱글톤은 static과 private을 통해 만들어지지만, 싱글톤 레지스트리는 평범한 public 자바 클래스라도 IoC 컨테이너를 이용해 싱글톤 방식으로 사용 가능

#### Singleton
  > 객체를 최초 한 번만 메모리에 할당해두고, 그 다음부터는 생성된 객체를 참조해서 사용하는 것. 일반적으로 하나만 존재하도록 강제 (반드시 그런 것은 아님)
  - Singleton bean은 Spring 컨테이너에서 한 번 생성됨
    - 컨테이너가 사라질 때 bean도 소멸
  - 생성된 인스턴스는 single beans cache에 저장되고, 해당 bean의 요청과 참조가 있으면 캐시된 객체를 반환

#### Prototype
  > 모든 getBean() 요청에 대해서 항상 새로운 객체를 생성해서 사용하는 것
  - 의존성 관계의 bean에 주입될 대 새로운 객체가 생성되어 주입됨
  - bean의 소멸은 정상적인 방식으로 garbage collector에 의해 수행됨

<br>

### 💡 참고

#### Singleton으로 적합한 객체

1. 상태가 없는 공유 객체 : 상태를 가지고 있지 않아 동기화 비용이 없음
2. 읽기용으로만 상태를 가진 공유 객체 : 읽기 전용이므로 여전히 동기화 비용이 없음
3. 공유가 필요한 상태를 지닌 공유 객체 : 반드시 공유해야 할 상태를 지닌 객체라면 적합
4. 쓰기가 가능한 상태를 지니면서도 사용빈도가 매우 높은 객체 : 쓰기 접근에 대한 동기화 비용을 감안하고서라도 고려할만함

#### 비 Singleton으로 적합한 객체
1. 쓰기가 가능한 상태를 지닌 객체 : 쓰기가 가능한 상태가 많아 동기화 비용이 객체 생성 비용보다 큰 경우
2. 상태가 노출되지 않은 객체 : 내부 상태를 외부에 노출하지 않는 빈을 참조하여 다른 의존 객체와는 독립적으로 작업을 수행하는 의존 객체