# JPA

## JPA란

**JPA**(Java Persistence API)는 자바 진영에서 ORM 기술 표준으로 사용되는 인터페이스의 모음

> **ORM(Object Relational Mapping)**<br>- 우리가 일반적으로 알고 있는 애플리케이션 class와 RDB의 테이블을 연결한다는 뜻.<br>- 기술적으로 객체를 RDB 테이블에 자동으로 영속화 해주는 것

- **실제적으로 구현된 것이 아니라** 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크
  - JPA를 구현한 구현체 ex) Hibernate, OpenJPA
  - Spring에서 주로 사용하는 것은 JPA를 사용하는 Spring Data JPA
    <img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/0172b0d1-4c7b-4974-a249-0d5ec58e1e95">

<br>

## JPA를 왜 사용할까

### JPA의 장점

- SQL문이 아닌 메소드를 통해 DB를 조작하기 때문에, 개발자가 객체 모델을 이용한 비즈니스 로직에만 집중할 수 있음

- 쿼리와 같이 필요한 선언문, 할당 등의 부수적인 코드가 줄어들고, 객체에 대한 코드를 별도로 작성하여 가독성이 높음

- 객체지향적 접근만 고려하여 개발하기 때문에 생산성 증가 및 유지보수 용이

- 데이터베이스가 바뀌더라도, 쿼리를 새로 짤 필요 없음

- 패러다임 불일치 해결 (상속, 연관 등)
  - 객체지향에 존재하는 상속관계를 데이터베이스는 지원하지 않음
    > JPA에서 상속 관계에 해당하는 객체를 매핑하는 3가지 방법이 존재.<br>- 조인 전략<br>- 싱글 테이블 전략<br>- 구현 클래스마다 테이블 전략
  - 객체지향에 존재하는 연관관계를 위해 Entity에 다른 Entity를 주입하여 사용

### JPA의 단점

- 프로젝트의 규모가 크고 복잡하여 설계가 잘못된 경우, 속도 저하 및 일관성이 무너질 수 있음

- 복잡하고 무거운 쿼리는 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL문을 사용하는 경우가 생김

<br>

## JPA의 상속 관계 처리

### 1. 조인 전략

<img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/e69107b7-6317-4c28-8bde-d6c87693c58b">

<br>

**엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아 외래 키로 사용하는 전략**

- 장점
  - 테이블이 정규화 됨
  - 외래키 참조 무결성 제약조건을 활용
  - 저장 공간을 효율적으로 사용
- 단점
  - 조회할 때 조인이 많이 사용되어 성능 저하 우려
  - 조회 쿼리가 복잡함
  - 데이터를 등록할 때 Insert SQL을 두 번 실행

<br>

### 2. 싱글 테이블 전략

<img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/89403c34-1624-499a-946d-92f9bb5b1a27" style="width: 200px">

<br>

**테이블 하나만 사용하여 구분 컬럼으로 어떤 자식이 저장되었는지 구분. 조인을 사용하지 않으므로 일반적으로 가장 빠름**

- 장점
  - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
  - 조회 쿼리가 단순
- 단점
  - 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야함
  - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있음, 따라서 상황에 따라 조회 성능이 오히려 느려질 수 있음

<br>

### 3. 구현 클래스마다 테이블 전략

<img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/f1fd2a2f-9ab2-4249-96af-600b66522baf">

**자식 엔티티마다 테이블을 만들고 각각에 필요한 컬럼들을 추가**

> DB 설계사, ORM 전문가 입장에서 양쪽 다 추천하지 않는 전략

- 장점
  - 서브 타입을 구분해 처리할 때 효과적
  - not null 제약 조건을 사용하지 않음
- 단점
  - 여러 자식 테이블을 함께 조회할 때 성능이 느림
  - 자식 테이블을 통합해서 쿼리를 쓰기가 어려움
