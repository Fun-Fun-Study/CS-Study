# 클로저(Closure)

> 클로저는 **함수**와 그 **함수가 선언됐을 때의 렉시컬 환경(Lexical environment)** 과의 조합이다.

## 스코프

> 스코프는 변수나 함수가 유효할 수 있는 범위를 말한다.

- 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙으로 작용

### 렉시컬 스코프(Lexical Scope)

> 함수를 어디에 선언하였는지에 따라 상위 스코프가 결정되는 것을 말한다

- 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.
- 함수가 정의되는 시점에 정해지므로 **정적 스코프(Static Scope)**라고 부르기도 한다.

### 동적 스코프(Dynamic Scope)

> 함수를 어디서 호출했는지에 따라 상위 스코프가 결정되는 것을 동적 스코프라고 한다.

## 렉시컬 환경

> 렉시컬 환경은 환경레코드와 외부 렉시컬 환경에 대한 참조로 이루어진다.

### 환경레코드(Environment Record)

> 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소

- 식별자와 식별자에 바인된 값을 기록한다.
- 자바스크립 엔진이 실행 전, 코드를 스캔하며 실행컨텍스트에 변수 정보를 저장(호이스팅)
- 이때 변수 정보가 저장되는 곳이 환경 레코드

  #### 환경레코드와 자바스크립트의 생성단계와 실행단계

  - 생성단계: 실행 전 스캔 및 준비단계. 실행컨텍스트를 생성하고 선언문만 먼저 실행하여 환경레코드에 기록
  - 실행단계: 실제 코드 실행. 필요한 경우 환경레코드의 정보를 참조 및 업데이트

  #### 환경레코드와 TDZ

  - 일시적사각지대(Temporal Dead Zone)이 발생하는 원인도 환경레코드
  - let, const로 선언한 변수는 **환경레코드에 초기값이 기록되지 않아 참조에러 발생**

### 외부 환경 참조

> 상위 스코프를 가리킨다. 외부 렉시컬 환경에 대한 참조를 통해 스코프 체인 구성

- 어떤 식별자를 참조할 때, 환경레코드를 우선 참조
- 환경레코드에 값이 없을 때 외부 환경 참조를 통해 상위 스코프에서 식별자가 존재하는 지 탐색
- 식별자를 찾을 때까지 상위 스코프 체이닝을 통해 탐색(전역 스코프까지)
  - 스코프 체이닝: 상위 스코프들을 연결 리스트로 연결한 것

## 클로저

- 함수가 선언될 때 그 당시 주변의 환경을 기억하는 것
- 함수가 속한 렉시컬 환경을 기억하여 함수가 렉스컬 스코프 밖에서 실행될 때도 이 스코프에 접근할 수 있게 해주는 기능

  ```javascript
  function sayHello() {
    const a = "Hello";
    const b = "World";

    function sumString() {
      console.log(a + " " + b);
    }

    return sumString;
  }
  const myFunc = sayHello();

  myFunc(); // "Hello World"
  ```

  - myFunc 변수는 sayHello 함수를 호출한 결과인 함수 sumString이 저장됨
  - 이때 sumString은 sayHello의 변수 a, b를 내부에서 사용
  - sayHello 바깥에서 호출한 myFunc가 sayHello 내부의 변수 a, b를 사용한 것과 같은 결과가 출력됨
  - 이를 가능하게 하는 것이 클로저
  - 함수의 선언시 클로저가 생성되어 당시의 주변환경(렉시컬 스코프)를 기억하고 사용할 수 있게 하는 것

## 클로저의 활용

### 정보은닉(접근 권한 제어)

- 누구나 볼 수 있고 변경이 가능한 **전역변수의 사용은 위험**
- 클로저를 사용하면 전역변수를 사용하지 않으면서도 클로저 함수 내부의 변수에 접근 가능하므로 전역변수의 사용을 줄일 수 있다.

### 상태 유지

- 현재의 상황을 기억하고 변경된 최신 상태를 유지하는 **state를 가지는 함수**로 만들 수 있다.
  ```javascript
  let toggle = (function () {
    let isShow = false;
    // 클로저를 반환
    return function () {
      // 상태 변경
      isShow = !isShow;
    };
  })();
  // 실행시마다 최신 상태를 기억
  toggle();
  ```
  - 만약 상태 유지를 위한 클로저에서 반복문 안의 인덱스 값을 사용하는 경우 반복문의 인덱스는 var 대신 let을 사용해야함
    - var 사용시 함수형 스코프로 함수 전체에서 같은 값을 가지게 됨 -> 블록안에서 호출시 모든 인덱스가 같은 값을 가지게 된다.
    - let 사용시 블록형 스코프로 각 반복문 블록안에서 독립된 값을 가지게 됨
  - 리액트의 useState가 이를 응용했다고 함

### 커링

- `f(a, b, c)`와 같이 여러 개의 인자를 한 번의 호출로 처리하는 함수를 `f(a)(b)(c)`와 같이 분리하여 인자를 하나씩 받는 여러개의 함수로 만드는 것을 커링이라고 한다.
- 함수 하나가 n개의 인자를 받는 대신, n개의 함수를 만들어 각각의 함수가 인자를 받도록하는 방식

  ```javascript
  // 일반 함수
  function fn(x, y) {
    return x + y;
  }
  fn(1, 2);

  // 일반 함수를 커링함수로 변환
  function curried_fn(x) {
    return function (y) {
      return x + y;
    };
  }

  const curried_fn2 = (x) => (y) => x + y;

  curried_fn(1)(2);
  curried_fn2(1)(2);
  ```

  #### 왜 커링 함수가 필요한가?

  - 일반 함수는 실행에 2개의 인자가 모두 필요
  - 커링 함수는 먼저 받는 인자를 사용하는 함수를 저장해 두었다가 나중에 받는 인자를 바꿔가며 재사용할 수 있음
  - **자바스크립트의 함수형 기법**

  #### 부분적용함수

  - 커링 함수의 응용
  - 여러개의 입력이 필요한 함수를 일부의 인자만 입력해 두었다가 나머지 입력을 하는 시점에 함수를 실행시키는 용도
  - 함수의 실행 시점을 뒤로 미룰 수 있다.
