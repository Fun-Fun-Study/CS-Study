## 🚂트랜잭션

### **1. 트랜잭션(Transaction)이란?**

**트랜잭션(Transaction)** 은 **데이터베이스에서의 논리적 작업 단위**이다.

**하나의 작업을 수행하기 위해 필요한 데이터베이스 연산 기능들을 모아놓은 것이며 분리되지 않도록 하여 작업의 완전성을 보장한다.**

트랜잭션을 통해서 데이터베이스의 회복과 병행 제어가 가능하다. 즉, 데이터베이스에서 오류가 발생하는 경우의 빠른 회복이나, 여러 사용자가 동시에 데이터베이스를 사용할 수 있도록 제어해주는 중요한 역할을 한다.

데이터베이스의 연산을 SQL문으로 표현한다면, 하나의 작업을 수행하는 SQL문의 집합으로 생각할 수도 있다.

상태를 변화시킨다는 것 → **SQL 질의어를 통해 DB에 접근하는 것**

- SELECT
- INSERT
- DELETE
- UPDATE


작업 단위 → **많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는 것**

```sql
예시) 사용자 A가 사용자 B에게 만원을 송금한다.

* 이때 DB 작업
- 1. 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경
- 2. 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경

현재 작업 단위 : 출금 UPDATE문 + 입금 UPDATE문
→ 이를 통틀어 하나의 트랜잭션이라고 한다.
- 위 두 쿼리문 모두 성공적으로 완료되어야만 "하나의 작업(트랜잭션)"이 완료되는 것이다. `Commit`
- 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야한다. `Rollback`
```

### **2. 트랜잭션의 특성**

트랜잭션이 성공적으로 처리되기 위해서는 **ACID**라는 네 가지 성질을 만족해야 한다.

**1. 원자성 (Automicity)**

**트랜잭션을 구성하는 연산은 반드시 모두 실행이 되거나 혹은 아예 실행되지 않아야 한다. 즉, 하나의 트랜잭션에서 일부 연산만 실행되면 안 된다.**

따라서 실행 도중에 오류가 발생하여 작업을 완료하지 못하였다면, 트랜잭션 전체를 취소하여 수행 이전으로 돌아가야 한다.

**2. 일관성 (Consistency)**

**트랜잭션이 완료된 상태에서도 트랜잭션 이전의 상황과 동일하게 데이터의 일관성이 있어야 한다.** 데이터에 모순이 있어서는 안 된다.

은행 송금 기능을 생각해보면, 트랜잭션 수행 이전의 송금자와 수금자의 잔액 합이 수행 후에 달라지거나, 혹은 잔액을 나타내는 자료형이 정수형에서 문자열로 바뀌는 등의 모순이 발생하면 안 된다.

**3. 독립성, 격리성 (Isolation)**

**트랜잭션은 다른 트랜잭션에 간섭을 주거나 받지 않고 독립적으로 수행되어야 한다.**

둘 이상의 트랜잭션이 병행 실행되는 경우, 현재 수행 중인 트랜잭션이 완료되기 전에 현재 트랜잭션이 생성한 중간 연산 결과를 다른 트랜잭션이 접근하면 안 된다.

독립성을 통해서, 사용자들은 여러 트랜잭션이 동시에 수행되고 있는 것처럼 느끼면서도 정확한 결과를 얻을 수 있게 된다.

**4. 지속성 (Durability)**

**트랜잭션이 성공적으로 완료되었을 때 그 결과는 영구적으로 반영되어야 한다.** 시스템의 장애가 발생하더라도 결과는 데이터베이스에 그대로 남아있어야 하며, 지속성을 보장하기 위해서 회복 기능이 필요하다.

### **3. 트랜잭션의 연산**

트랜잭션의 연산으로는 크게 **Commit**과 **Rollback** 두 가지가 있다.

**1. Commit 연산**

Commit 연산은 하나의 트랜잭션이 성공적으로 종료된 후, 데이터베이스가 일관된 상태를 유지할 때 **갱신 연산이 완료되었다고 트랜잭션 관리자에게 알려주고 결과를 최종적으로 데이터베이스에 반영하는 연산**이다.

**2. Rollback 연산**

Rollback 연산은 하나의 트랜잭션이 비정상적으로 종료되어 데이터베이스의 일관성을 잃었을 때 **트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 트랜잭션 수행 이전의 상태로 돌아가는 연산**이다.

Rollback을 하는 경우엔 해당 트랜잭션을 재시작하거나 폐기한다.

![트랜젝션1](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/504fa132-1567-4915-8d8e-022af3bf2d33)


⭐ *상황이 주어지면 DB 측면에서 어떻게 해결할 수 있을지 대답할 수 있어야 함*


### **4. 트랜잭션의 상태**

트랜잭션의 연산을 수행할 때, 트랜잭션의 5가지 상태가 존재하며, 과정은 아래의 그림과 같다.

![트랜젝션2](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/c0dcc6b0-0041-4e0d-aa62-b65c9c00a9b9)

**1. 활성화(Active)** **:** 트랜잭션이 작업을 시작하여 실행 중인 상태

**2. 실패(Failed) :** 트랜잭션에 오류가 발생하여 실행이 중단된 상태

**3. 철회(Aborted) :** 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

**4. 부분 완료(Partially commited) :** 트랜잭션의 마지막 연산까지 실행하고 commit 요청이 들어온 직후의 상태. 최종 결과를 데이터베이스에 아직 반영하지 않은 상태.

**5. 완료(Commited) :** 트랜잭션이 성공적으로 종료되어 commit 연산을 실행한 후의 상태

- permanent : 영구적인

## 🧸 트랜잭션 스케줄 & 충돌, 뷰 직렬

### **1. 트랜잭션 스케줄**

데이터베이스에서 여러 트랜잭션이 동시에 수행될 때, 수행되는 트랜잭션의 순서에 따라서 결과가 달라질 수 있다. 이때 처리하는 순서를 스케줄이라고 한다.

트랜잭션 스케줄은 크게 3가지로 이루어져 있다.

- **직렬(Serial) 스케줄** : 트랜잭션 별로 연산을 순차적으로 수행하는 것
- **비직렬(Non-serial) 스케줄** : 인터리빙(Interleaving) 방식을 이용하여 트랜잭션들을 병행하여 수행하는 것
- **직렬 가능(Serializable) 스케줄** : 직렬성을 가진 스케줄. 트랜잭션이 동시에 수행되더라도 직렬 스케줄과 동일한 결과를 갖는 것

### **2. 충돌 직렬 가능**

스케줄에 따라 결과가 달라지는 이유는 **충돌(Conflict)**이 발생하기 때문이다.

둘 이상의 트랜잭션에서 동일한 데이터에 접근할 때, 쓰기(write)연산이 하나라도 발생하면 충돌이 발생한다. 연산의 순서를 바꾸면 결과가 달라질 수 있기 때문이다.

만약 어떤 스케줄 S가 일련의 비충돌 명령어의 교환으로 스케줄 S'으로 변환될 수 있다면, S와 S'은 **충돌 동등(Conflict equivalent)** 이라고 한다.

그리고 S가 직렬 스케줄과 충돌 동등, 즉 동일한 결과를 갖는다면 S를 **충돌 직렬 가능(Conflict serializable)** 이라고 한다.

![트랜젝션3](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/73fe1166-aff9-4bdc-9766-19155bf5df13)

위 그림과 같이 왼쪽의 스케줄이 오른쪽의 직렬 스케줄과 동일한 결과를 가지면 충돌 직렬 가능이라고 한다. (둘은 충돌 동등이기도 하다.)

만약 아래처럼 스케줄이 구성된 경우, 직렬 스케줄인 <T1, T2> or <T2, T1> 어느 쪽과도 결과가 일치하지 않으므로 충돌 직렬 가능이라고 할 수 없다.

![트랜젝션4](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/0d8ae9fb-3458-4d39-af29-76f4b8d57938)

<T2, T1>의 경우 → T2의 write(X)로 인해 T1이 원한 X값과 다른 X가 read(X) 된다. → 충돌

<T1, T2>의 경우 → 위와 마찬가지로 T1의 write(x)로 수정이 원한대로 안된다. → 충돌

그러므로 비충돌 명령어의 교환으로 어느 직렬 스케쥴로도 변환이 불가능하다.

### **3. 뷰 직렬 가능**

같은 트랜잭션 집합을 가진 두 스케줄 S와 S'이 다음 세 조건을 만족하면 S와 S'은 **뷰 동등(View equivalent)** 이라고 한다.

**1) 데이터 x에 대하여 S에서 트랜잭션 Ti가 x의 초깃값을 읽는다면, S'에서도 Ti가 초깃값을 읽어야 한다.**

**2) S에서 트랜잭션 Ti가 수행한 모든 read(x)의 연산 값이 Tj가 수행한 write(x)가 생성한 값이라면, S'에서 Ti가 수행한 모든 read(x)의 연산 값도 Tj가 수행한 write(x)가 생성한 값이어야 한다.**

**3) S에서 Ti가 마지막 write(x)를 수행했다면, S'에서도 Ti가 마지막으로 write(x)를 수행해야 한다.**

즉, 동일한 데이터 x에 대해서 '최초 읽기', '쓰기/읽기', '마지막 쓰기'를 수행하는 트랜잭션의 순서가 동일해야 한다는 의미이다.

그리고 마찬가지로 S가 직렬 스케줄과 뷰 동등이라면 S를 **뷰 직렬 가능(View conflict serializable)** 이라고 한다.

모든 충돌 직렬 가능 스케줄은 뷰 직렬 가능이며, 역은 성립하지 않는다. 아래가 예시이다.

![트랜젝션5](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/fccbdcc0-9fa3-4f86-b15d-889da915f4d7)

이 스케줄은 <T1, T2, T3> 직렬 스케줄과 뷰 동등이다. 조건 1과 3을 만족하고, write 연산 후의 read 연산이 없기 때문에 조건 2 또한 만족한다.

![트랜젝션6](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/0db5b1fa-658a-49ea-9e67-659c51f3cec7)

<T1, T2, T3> 직렬 스케줄

반면 충돌 직렬 가능은 만족하지 않는다.

- 추가
    
    우선 충돌직렬가능성의 정의는 다음과 같습니다.
    
    동일한 데이터 Q에 대해 접근하는 트랜잭션 Ti, Tj 의 내부의 연속적인 연산이 Ii, Ij 일 경우
    
    Ii = read(Q), Ij = read(Q) : 비충돌
    
    Ii = read(Q), Ij = write(Q) : 충돌
    
    Ii = write(Q), Ij = read(Q) : 충돌
    
    Ii = write(Q), Ij = write(Q) : 충돌
    
    ---
    
    즉, 서로 다른 트랜잭션에서 동일한 자원에 대해 연속적으로 읽기/읽기를 제외한 쓰기(write)가 하나라도 발생하면 충돌입니다.(읽기/쓰기, 쓰기/읽기, 쓰기/쓰기) 이런 충돌이 순환 사이클을 그리는 경우 충돌직렬이 불가능하게 됩니다.
    
    [견고하게 트랜잭션 스케줄(Transaction Schedules) 개념 잡기](https://le2ksy.tistory.com/6)
    
- 문제
    
    ---
    
    [직렬성(serializable), 충돌직렬, 뷰직렬 스케줄](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=renucs&logNo=220542396476)
    
    [트랜잭션_병행제어 _ 충돌 직렬, 뷰 직렬 가능 스케쥴, 직렬성](https://swingswing.tistory.com/27)
    