## Index(인덱스)
<br>

#### 목적
```
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터 베이스 테이블의 검색 속도를 향상시키기 위한 자료 구조
```
테이블의 칼럼을 색인화한다.
<br>
※색인화 : 따로 파일로 저장을 의미
SELECT 쿼리의 WHERE 절이나 JOIN 예약어를 사용했을때만 인덱스를 사용됩니다.
※DELETE,UPDATE,INSERT 쿼리는 해당 사항이 없으며 사용시 느려진다.
<br>

데이터베이스 안의 레코드를 처음부터 Full-Scan하지 않고, B+ Tree로 구성된 구조에서 Index 파일 검색으로 속도를 향상시키는 기술이다.

#### 파일 구성
테이블 생성 시, 3가지 파일 생성
- FRM : 테이블 구조 저장 파일
- MYI : 인덱스에 해당하는 컬럼을 색인화 하여 저장
- MYD : 실제 데이터 파일 저장

#### INDEX의 장점
- 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킴
- 질의나 보고서에서 그룹화 작업의 속도를 향상시킴
  
#### INDEX의 단점
- INDEX 생성을 통한 .mdb 파일 크기 증가
- 한 페이지를 동시 수정할 수 있는 병행성 감소
- 인덱스 된 Field의 Data를 업데이트하거나, Record를 추가 또는 삭제시 성능 저하
- 데이터 변경이 번번히 발생시, INDEX를 재작성함에 따라 성능에 영향을 미침

#### INDEX가 필요한 경우
1) Where 절에서 자주 사용되는 컬럼
2) 외래키가 사용되는 컬럼
3) Join에 자주 사용되는 컬럼

#### INDEX 사용을 피해야 하는 경우
1) Data 중복도가 높은 컬럼
2) DML이 자주 일어나는 컬럼

#### DML을 사용시 INDEX의 처리과정
 - Insert
> 1) 기존 Block에 여유가 없을 경우, 새로운 Data가 입력
> 2) 새로운 Block을 할당 받은 후, Key를 옮기는 작업을 수행
> 3) Index split 작업 동안, 해당 Block의 Key 값에 대해서 DML이 블로킹이 진생(대기 이벤트 발생)
> 4) 이때 Block의 논리적인 순서와 물리적인 순서가 달라질 수 있다.
 - Delete
> 1) Data delete시 Data가 지워지고, 다른 Data가 그 공간을 사용 가능
> 2) Index에서 Data가 delete된 경우 : Data가 지워지지 않고, 사용 안됨 표시만 해둔다
> <br>
> -> Table의 Data 수와 Index의 Data 수가 다를 수 있다.


#### INDEX 관리 방식
- ##### B-Tree 자료구조

  이진 탐색트리와 유사한 자료구조

  자식 노드를 둘이상 가질 수 있고 Balanced Tree 라는 특징이 있다 → 즉 탐색 연산에 있어 O(log N)의 시간복잡도를 갖는다.

  모든 노드들에 대해 값을 저장하고 있으며 포인터 역할을 동반한다.

- ##### B+Tree 자료구조

  B-Tree를 개선한 형태의 자료구조

  값을 리프노드에만 저장하며 리프노드들 끼리는 링크드 리스트로 연결되어 있다 → 때문에 부등호문 연산에 대해 효과적이다.

  리프 노드를 제외한 노드들은 포인터의 역할만을 수행한다.

- ##### HashTable 자료구조

  해시 함수를 이용해서 값을 인덱스로 변경 하여 관리하는 자료구조

  일반적인 경우 탐색, 삽입, 삭제 연산에 대해 O(1)의 시간 복잡도를 갖는다.

  다른 관리 방식에 비해 빠른 성능을 갖는다.

  최악의 경우 해시 충돌이 발생하는 것으로 탐색, 삽입, 삭제 연산에 대해 O(N)의 시간복잡도를 갖는다.

  값 자체를 변경하기 때문에 부등호문, 포함문등의 연산에 사용할 수 없다.