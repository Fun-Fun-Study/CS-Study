## 🚂트랜잭션

### **1. 트랜잭션(Transaction)이란?**

**트랜잭션(Transaction)** 은 **데이터베이스에서의 논리적 작업 단위**이다.

**하나의 작업을 수행하기 위해 필요한 데이터베이스 연산 기능들을 모아놓은 것이며 분리되지 않도록 하여 작업의 완전성을 보장한다.**

트랜잭션을 통해서 데이터베이스의 회복과 병행 제어가 가능하다. 즉, 데이터베이스에서 오류가 발생하는 경우의 빠른 회복이나, 여러 사용자가 동시에 데이터베이스를 사용할 수 있도록 제어해주는 중요한 역할을 한다.

데이터베이스의 연산을 SQL문으로 표현한다면, 하나의 작업을 수행하는 SQL문의 집합으로 생각할 수도 있다.

상태를 변화시킨다는 것 → **SQL 질의어를 통해 DB에 접근하는 것**

- SELECT
- INSERT
- DELETE
- UPDATE


작업 단위 → **많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는 것**

```sql
예시) 사용자 A가 사용자 B에게 만원을 송금한다.

* 이때 DB 작업
- 1. 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경
- 2. 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경

현재 작업 단위 : 출금 UPDATE문 + 입금 UPDATE문
→ 이를 통틀어 하나의 트랜잭션이라고 한다.
- 위 두 쿼리문 모두 성공적으로 완료되어야만 "하나의 작업(트랜잭션)"이 완료되는 것이다. `Commit`
- 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야한다. `Rollback`
```

### **2. 트랜잭션의 특성**

트랜잭션이 성공적으로 처리되기 위해서는 **ACID**라는 네 가지 성질을 만족해야 한다.

**1. 원자성 (Automicity)**

**트랜잭션을 구성하는 연산은 반드시 모두 실행이 되거나 혹은 아예 실행되지 않아야 한다. 즉, 하나의 트랜잭션에서 일부 연산만 실행되면 안 된다.**

따라서 실행 도중에 오류가 발생하여 작업을 완료하지 못하였다면, 트랜잭션 전체를 취소하여 수행 이전으로 돌아가야 한다.

**2. 일관성 (Consistency)**

**트랜잭션이 완료된 상태에서도 트랜잭션 이전의 상황과 동일하게 데이터의 일관성이 있어야 한다.** 데이터에 모순이 있어서는 안 된다.

은행 송금 기능을 생각해보면, 트랜잭션 수행 이전의 송금자와 수금자의 잔액 합이 수행 후에 달라지거나, 혹은 잔액을 나타내는 자료형이 정수형에서 문자열로 바뀌는 등의 모순이 발생하면 안 된다.

**3. 독립성, 격리성 (Isolation)**

**트랜잭션은 다른 트랜잭션에 간섭을 주거나 받지 않고 독립적으로 수행되어야 한다.**

둘 이상의 트랜잭션이 병행 실행되는 경우, 현재 수행 중인 트랜잭션이 완료되기 전에 현재 트랜잭션이 생성한 중간 연산 결과를 다른 트랜잭션이 접근하면 안 된다.

독립성을 통해서, 사용자들은 여러 트랜잭션이 동시에 수행되고 있는 것처럼 느끼면서도 정확한 결과를 얻을 수 있게 된다.

**4. 지속성 (Durability)**

**트랜잭션이 성공적으로 완료되었을 때 그 결과는 영구적으로 반영되어야 한다.** 시스템의 장애가 발생하더라도 결과는 데이터베이스에 그대로 남아있어야 하며, 지속성을 보장하기 위해서 회복 기능이 필요하다.

### **3. 트랜잭션의 연산**

트랜잭션의 연산으로는 크게 **Commit**과 **Rollback** 두 가지가 있다.

**1. Commit 연산**

Commit 연산은 하나의 트랜잭션이 성공적으로 종료된 후, 데이터베이스가 일관된 상태를 유지할 때 **갱신 연산이 완료되었다고 트랜잭션 관리자에게 알려주고 결과를 최종적으로 데이터베이스에 반영하는 연산**이다.

**2. Rollback 연산**

Rollback 연산은 하나의 트랜잭션이 비정상적으로 종료되어 데이터베이스의 일관성을 잃었을 때 **트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 트랜잭션 수행 이전의 상태로 돌아가는 연산**이다.

Rollback을 하는 경우엔 해당 트랜잭션을 재시작하거나 폐기한다.

![트랜젝션1](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/504fa132-1567-4915-8d8e-022af3bf2d33)


⭐ *상황이 주어지면 DB 측면에서 어떻게 해결할 수 있을지 대답할 수 있어야 함*


### **4. 트랜잭션의 상태**

트랜잭션의 연산을 수행할 때, 트랜잭션의 5가지 상태가 존재하며, 과정은 아래의 그림과 같다.

![트랜젝션2](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/c0dcc6b0-0041-4e0d-aa62-b65c9c00a9b9)

**1. 활성화(Active)** **:** 트랜잭션이 작업을 시작하여 실행 중인 상태

**2. 실패(Failed) :** 트랜잭션에 오류가 발생하여 실행이 중단된 상태

**3. 철회(Aborted) :** 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

**4. 부분 완료(Partially commited) :** 트랜잭션의 마지막 연산까지 실행하고 commit 요청이 들어온 직후의 상태. 최종 결과를 데이터베이스에 아직 반영하지 않은 상태.

**5. 완료(Commited) :** 트랜잭션이 성공적으로 종료되어 commit 연산을 실행한 후의 상태

- permanent : 영구적인

## 🧸 트랜잭션 스케줄 & 충돌, 뷰 직렬

### **1. 트랜잭션 스케줄**

데이터베이스에서 여러 트랜잭션이 동시에 수행될 때, 수행되는 트랜잭션의 순서에 따라서 결과가 달라질 수 있다. 이때 처리하는 순서를 스케줄이라고 한다.

트랜잭션 스케줄은 크게 3가지로 이루어져 있다.

- **직렬(Serial) 스케줄** : 트랜잭션 별로 연산을 순차적으로 수행하는 것
- **비직렬(Non-serial) 스케줄** : 인터리빙(Interleaving) 방식을 이용하여 트랜잭션들을 병행하여 수행하는 것
- **직렬 가능(Serializable) 스케줄** : 직렬성을 가진 스케줄. 트랜잭션이 동시에 수행되더라도 직렬 스케줄과 동일한 결과를 갖는 것

### **2. 충돌 직렬 가능**

스케줄에 따라 결과가 달라지는 이유는 **충돌(Conflict)**이 발생하기 때문이다.

둘 이상의 트랜잭션에서 동일한 데이터에 접근할 때, 쓰기(write)연산이 하나라도 발생하면 충돌이 발생한다. 연산의 순서를 바꾸면 결과가 달라질 수 있기 때문이다.

만약 어떤 스케줄 S가 일련의 비충돌 명령어의 교환으로 스케줄 S'으로 변환될 수 있다면, S와 S'은 **충돌 동등(Conflict equivalent)**이라고 한다.

그리고 S가 직렬 스케줄과 충돌 동등, 즉 동일한 결과를 갖는다면 S를 **충돌 직렬 가능(Conflict serializable)**이라고 한다.

![트랜젝션3](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/73fe1166-aff9-4bdc-9766-19155bf5df13)

위 그림과 같이 왼쪽의 스케줄이 오른쪽의 직렬 스케줄과 동일한 결과를 가지면 충돌 직렬 가능이라고 한다. (둘은 충돌 동등이기도 하다.)

만약 아래처럼 스케줄이 구성된 경우, 직렬 스케줄인 <T1, T2> or <T2, T1> 어느 쪽과도 결과가 일치하지 않으므로 충돌 직렬 가능이라고 할 수 없다.

![트랜젝션4](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/0d8ae9fb-3458-4d39-af29-76f4b8d57938)

<T2, T1>의 경우 → T2의 write(X)로 인해 T1이 원한 X값과 다른 X가 read(X) 된다. → 충돌

<T1, T2>의 경우 → 위와 마찬가지로 T1의 write(x)로 수정이 원한대로 안된다. → 충돌

그러므로 비충돌 명령어의 교환으로 어느 직렬 스케쥴로도 변환이 불가능하다.

### **3. 뷰 직렬 가능**

같은 트랜잭션 집합을 가진 두 스케줄 S와 S'이 다음 세 조건을 만족하면 S와 S'은 **뷰 동등(View equivalent)** 이라고 한다.

**1) 데이터 x에 대하여 S에서 트랜잭션 Ti가 x의 초깃값을 읽는다면, S'에서도 Ti가 초깃값을 읽어야 한다.**

**2) S에서 트랜잭션 Ti가 수행한 모든 read(x)의 연산 값이 Tj가 수행한 write(x)가 생성한 값이라면, S'에서 Ti가 수행한 모든 read(x)의 연산 값도 Tj가 수행한 write(x)가 생성한 값이어야 한다.**

**3) S에서 Ti가 마지막 write(x)를 수행했다면, S'에서도 Ti가 마지막으로 write(x)를 수행해야 한다.**

즉, 동일한 데이터 x에 대해서 '최초 읽기', '쓰기/읽기', '마지막 쓰기'를 수행하는 트랜잭션의 순서가 동일해야 한다는 의미이다.

그리고 마찬가지로 S가 직렬 스케줄과 뷰 동등이라면 S를 **뷰 직렬 가능(View conflict serializable)**이라고 한다.

모든 충돌 직렬 가능 스케줄은 뷰 직렬 가능이며, 역은 성립하지 않는다. 아래가 예시이다.

![트랜젝션5](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/fccbdcc0-9fa3-4f86-b15d-889da915f4d7)

이 스케줄은 <T1, T2, T3> 직렬 스케줄과 뷰 동등이다. 조건 1과 3을 만족하고, write 연산 후의 read 연산이 없기 때문에 조건 2 또한 만족한다.

![트랜젝션6](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/0db5b1fa-658a-49ea-9e67-659c51f3cec7)

<T1, T2, T3> 직렬 스케줄

반면 충돌 직렬 가능은 만족하지 않는다.

- 추가
    
    우선 충돌직렬가능성의 정의는 다음과 같습니다.
    
    동일한 데이터 Q에 대해 접근하는 트랜잭션 Ti, Tj 의 내부의 연속적인 연산이 Ii, Ij 일 경우
    
    Ii = read(Q), Ij = read(Q) : 비충돌
    
    Ii = read(Q), Ij = write(Q) : 충돌
    
    Ii = write(Q), Ij = read(Q) : 충돌
    
    Ii = write(Q), Ij = write(Q) : 충돌
    
    ---
    
    즉, 서로 다른 트랜잭션에서 동일한 자원에 대해 연속적으로 읽기/읽기를 제외한 쓰기(write)가 하나라도 발생하면 충돌입니다.(읽기/쓰기, 쓰기/읽기, 쓰기/쓰기) 이런 충돌이 순환 사이클을 그리는 경우 충돌직렬이 불가능하게 됩니다.
    
    [견고하게 트랜잭션 스케줄(Transaction Schedules) 개념 잡기](https://le2ksy.tistory.com/6)
    
- 문제
    
    ---
    
    [직렬성(serializable), 충돌직렬, 뷰직렬 스케줄](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=renucs&logNo=220542396476)
    
    [트랜잭션_병행제어 _ 충돌 직렬, 뷰 직렬 가능 스케쥴, 직렬성](https://swingswing.tistory.com/27)
    

## 🌵 병행 제어

### **1. 병행 제어(Concurrency Control)란?**

병행 제어에 앞서, 먼저 병행에 대해서 알아보자.

**병행(Concurrency)**은 **매우 빠르게 여러 트랜잭션 사이를 이동하면서 조금씩 처리를 수행하는 방식**이다.

따라서 실제로는 한 번에 한 트랜잭션만 수행하지만, 마치 동시에 여러 트랜잭션을 수행하는 것처럼 보이도록 하는 것이다.

**병행 제어(Concurrency Control)**는 이렇게 **트랜잭션이 병행 수행될 때 트랜잭션이 데이터베이스의 일관성을 파괴하지 않고, 다른 트랜잭션에 영향을 주지 않도록 트랜잭션 간의 상호작용을 제어하는 것**을 말한다.

병행 제어의 목적은 다음과 같다.

- **데이터베이스의 일관성 유지**
- **데이터베이스 공유 최대화**
- **시스템 활용도 최대화**
- **사용자 응답 시간 최소화**
- **단위 시간당 트랜잭션 처리 건수 최대화**

### **2. 병행의 문제점**

병행 제어를 하지 않고, 트랜잭션들이 동시에 데이터베이스에 접근할 수 있다면 여러 문제점이 발생한다.

**1. 갱신 분실 (Lost Update)**

갱신 분실은 **같은 데이터에 대해 둘 이상의 트랜잭션이 동시에 갱신할 때, 갱신 결과의 일부가 없어지는 현상**이다.

![트랜젝션6](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/5b9d4fa1-3b02-4f0e-bbee-a5f482b1aae4)

위와 같은 예시를 생각해보자.

두 개의 트랜잭션이 수행되고, 최종적인 결과로는 x에 800이 더해져야 한다.

하지만, 같은 데이터인 x에 대해서 트랜잭션 1이 갱신하기 이전에 트랜잭션 2가 x값을 받아와서 결국 최종 결과는 x + 500이 되어버린다.

이렇게 둘 이상의 트랜잭션이 동시에 같은 데이터를 갱신하면 올바르게 갱신되지 못한다.

**2. 모순성(Inconsistency)**

모순성은 **하나의 트랜잭션이 여러 데이터 갱신 연산을 수행할 때, 일관성 없는 상태의 데이터베이스에서 데이터를 가져옴으로써 데이터의 불일치가 발생하는 것**을 의미한다.

![트랜젝션7](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/38fea2ee-d1c3-4b59-816d-98808bba2607)

위의 예시를 살펴보자. 트랜잭션 1이 완료되기 이전에 트랜잭션 2가 수행되는 모습이다.

따라서, 최종 결과로는 y에 500을 더해준 후 4를 곱한 결과가 나와야 하지만, 4를 곱한 y값에 500을 더하는 모순이 발생한다.

트랜잭션 2의 입장에서는 일관성이 유지되지만, 트랜잭션 1의 입장에서는 실행 전후 차이가 500 만큼이 발생해야 하는데 그보다 더 큰 차이가 발생하기 때문에 데이터의 불일치가 발생한다.

**3. 연쇄 복귀 (Cascading Rollback)**

연쇄 복귀는 **병행 수행되던 둘 이상의 트랜잭션 중 어느 한 트랜잭션에 오류가 발생하여 Rollback 하는 경우 다른 트랜잭션들도 함께 Rollback 되는 현상**을 말한다.

**4. 비완료 의존성 (uncommitted Dependency)**

**하나의 트랜잭션 수행이 실패한 후 회복하기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상**을 말한다.

### **3. 병행 제어 기법**

**1. 로킹 (Locking)**

로킹은 **트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는(lock) 병행 제어 기법**이다.

이를 통해 **상호 배제(Mutual Exclusive) 기능**을 제공하며, 잠금을 설정한 트랜잭션이 해제(unlock)할 때까지 데이터를 **독점적**으로 사용할 수 있다.

한 번에 로킹 할 수 있는 데이터의 크기를 **로킹 단위**라고 하며 필드(Field), 레코드(Record), 테이블(Table), 파일(File), 데이터베이스(Database) 모두 로킹 단위가 될 수 있다.

- 단위?
    
    **Database(데이터베이스)** - 저장소에 구분되는 가장 큰 단위
    
    **Table(테이블)** - 데이터베이스에 뭔가를 저장하기 위해 맨 첫 단계에 만드는 테이블
    
    **Column(컬럼)** - 관계형 데이터베이스에서 행(레코드)을 분류하는 기준
    
    **Row(행)** - 데이터를 저장하는 값으로 컬럼(필드) 내의 단 하나의 값
    
    **컬럼(Column)과 필드(Filed)**
    는 같은 의미이고 **행(Row)과 레코드(Record)**
    는 같은 의미이다.
    
    https://t1.daumcdn.net/cfile/tistory/99B2F3495B61CF4806
    
    https://t1.daumcdn.net/cfile/tistory/990ADF495B61CF4835
    
    [프로그램 기초 상식 자료 구성의 단위 모음](https://doppelman.tistory.com/entry/IT-computer-database-basic-data)
    

로킹 단위의 크기에 따라 성능의 차이가 발생한다.

**로킹 단위가 클수록 병행 제어가 단순해지고 관리하기가 편하지만 병행성 수준이 낮아진다.**

**반면 로킹 단위가 작을수록 병행 제어가 복잡해지고 오버헤드가 증가하지만, 병행성 수준이 높아지고 데이터베이스 공유도가 높아진다.**

- 왜?
    
    로킹 단위가 작으면 다른 트랜잭션이 실행되었을 때 해당 단위에 접근을 하는지 체크해야됨. 이 경우 사용되는 시간, 메모리, 자원 (오버헤드)가 증가한다.
    

기본적으로 로킹은 **lock**과 **unlock** 연산을 사용한다. 로킹 규약은 다음과 같다.

**1) 트랜잭션 T가 공유 데이터 x를 접근하려면 먼저 lock(x)을 해야 한다.**

**2) 공유 데이터를 사용한 T는 반드시 unlock(x)을 해야 한다.**

**3) 다른 트랜잭션에 의해 lock(x)가 실행되었다면, 트랜잭션 T는 lock(x)을 실행하지 못한다.**

**4) 트랜잭션 T가 lock(x) 한 것을 다른 트랜잭션이 unlock(x)할 수 없다.**

이러한 로킹 규약에는 제약이 있다.

하나의 트랜잭션만이 공유 데이터를 사용할 수 있는데, 실제로 오직 읽기(read)만 하는 경우에는 동시에 접근해도 문제가 없기 때문에 이런 경우에 효율적이지 못하다.

따라서 위와 같은 문제점을 해결하기 위해 사용되는 것이 **2단계 로킹 규약**이다.

로킹 기법은 **교착 상태(Dead lock)**가 발생할 수 있다는 한계가 있다.

**교착 상태란, 여러 트랜잭션이 특정 데이터에 lock을 한 채 다른 트랜잭션이 lock을 수행한 데이터에 접근하려고 할 때 실행을 하지 못하고 서로 무한정 기다리는 상태**를 말한다.

![트랜젝션8](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/10cbdf50-50e3-44c4-bb1d-158b674548a9)

위의 예시처럼, 트랜잭션 T1에서 x를 lock 하고 T2에서 y를 lock 한 경우에 T1도 y에 접근할 수 없고 T2도 x에 접근할 수 없다. 따라서 서로 무한정 기다리게 된다.

**2. 2단계 로킹 규약 (Two-Phase Locking, 2PL)**

2단계 로킹(Two-Phase Locking, 2PL) 규약은 **각 트랜잭션의 lock과 unlock 요청을 2단계로 실시하는 방식**이다.

단계는 확장 단계(Growing phase)와 축소 단계(shrinking phase)로 나뉜다.

이를 통해 직렬성을 보장하는 대표적인 로킹 규약이지만 여전히 lock 연산으로 인한 교착상태를 예방할 수는 없다는 단점이 있다.

- **확장 단계(Growing phase)** : 새로운 lock 연산만을 수행할 수 있고, unlock 연산은 수행할 수 없는 단계
- **축소 단계(shrinking phase)** : unlock 연산을 수행할 수 있고, lock연산은 수행할 수 없는 단계

2단계 로킹 규약은 **트랜잭션 내의 모든 lock 연산이 첫 번째 unlock 연산 이전에 위치해야 한다**. 따라서 하나의 트랜잭션에서 데이터에 대한 연산을 완전히 끝낸 후 unlock 하므로 직렬성이 보장된다.

아래의 그림에서 왼쪽은 2단계 로킹 규약을 만족하는 경우, 오른쪽은 만족하지 않는 경우의 예시이다.

![트랜젝션9](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/0e11ec01-01e9-4387-9fdb-7edef6a362f9)

**3. 타임스탬프 순서 (Timestamp ordering) 기법**

타임스탬프 순서 기법은 **비직렬 트랜잭션을 타임스탬프 순서에 따라 직렬화 시키는 방법**이다.

데이터에 접근하는 시간(Timestamp)을 미리 정해두어 부여된 시간 순서대로 데이터에 접근하며, lock을 사용하지 않고 시간을 나눠 사용하기 때문에 교착 상태(Dead lock)가 발생하지 않는다.

하지만, Rollback 발생률이 높고 연쇄 복귀를 초래할 수 있는 단점이 있다.

타임스탬프는 트랜잭션을 유일하게 식별할 수 있는 식별자의 역할을 할 수 있으며 트랜잭션의 시작 시간으로 간주할 수 있다. 타임스탬프를 생성하는 방법은 논리적 계수기(Logical Count) 또는 시스템 클럭(System Clock)을 이용한다.

- **논리적 계수기** : 계수기를 사용하여 트랜잭션이 들어올 때마다 카운터를 하나씩 증가
- **시스템 클럭** : 시스템의 고유 시계 사용

타임스탬프 순서 기법의 운영 방식은 다음과 같다.

read_TS(x) : read(x) 연산을 성공적으로 수행한 트랜잭션들의 타임스탬프 중 가장 큰 것

write_TS(x) : write(x) 연산을 성공적으로 수행한 트랜잭션들의 타임스탬프 중 가장 큰 것

**1) 트랜잭션 T가 read(x)를 수행하려고 할 때**

TS(T) < write_TS(x)이면, read(x)를 거부하고 T 취소 & 복귀

TS(T) ≥ write_TS(x)이면, read(x)를 허용하고 read_TS(x) = TS(T)로 갱신

**2) 트랜잭션 T가 write(x)를 수행하려고 할 때**

TS(T) < read_TS(x)이면, write(x)를 거부하고 T 취소 & 복귀

TS(T) < write_TS(x)이면, write(x)를 수행한 것으로 간주하고 무시(Thomas write rule, 트랜잭션 취소 감소 목적)

이외의 경우, write(x)를 허용하고 write_TS(x) = TS(T)로 갱신

- 문제
    
    [타임스탬프 순서 기법, 토마스 기록규칙](https://swingswing.tistory.com/45)
    

**4. 낙관적 병행 제어 (Optimistic Concurrency Control)**

낙관적 병행 제어는 **트랜잭션 수행 동안은 어떠한 검사를 하지 않고, 트랜잭션이 종료된 이후에 일괄적으로 검사하는 방식**이다. 수행 도중에는 트랜잭션을 위해 유지되는 데이터 항목들의 지역 사본에 대해서만 갱신하고, 트랜잭션이 종료되고 난 후에 직렬화를 검증하여 검증되면 데이터베이스에 한 번에 반영하는 방식이다.

병행 수행하고자 하는 대부분의 트랜잭션이 판독 전용(Read-only)인 경우, 트랜잭션 간 충돌률이 매우 낮기 때문에 병행 제어 기법을 사용하지 않고도 대부분 일관성을 유지한다는 점을 이용한 방식이다.

**5. 다중 버전 병행 제어 (Multi-version Concurrency Control)**

**한 데이터에 대해 여러 버전의 값을 유지하며 관리하는 방식**이다. 타임스탬프의 개념을 이용하며, 다중 버전 타임 스탬프 기법이라고도 한다.

여러 버전의 타임스탬프를 비교하여 스케줄상 직렬 가능성이 보장되는 타임스탬프를 선택한다.

충돌이 발생할 경우 연쇄 복귀가 발생할 수 있는 단점이 있다.

- 추가
    
    [MVCC (다중버전 동시성 제어)](https://nays111.tistory.com/112)