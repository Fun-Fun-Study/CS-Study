# 저장 프로시저란?

**저장 프로시저(Stored Procedure)** : DB 내부에 저장된 일련의 SQL 명령문들을 하나의 함수처럼 실행하기 위한 쿼리의 집합

> 요약💡 작성한 SQL을 옵티마이저가 해석하고 결과물을 만들어내는 데 많은 비용이 들지만, Stored Procedure로 만들어 놓으면 비용을 절약


## 일반 SQL VS 저장 프로시저

### 일반 쿼리문 작동 방식

  <img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/836bca98-2cf4-4133-abbc-365c73a055ec">

  - **구문 분석** : 구문 오류 확인
  - **개체 이름 확인** : table 유무 및 컬럼 유무 확인
  - **사용 권한** : 해당 개체에 현재 접근 중인 사용자 권한 확인
  - **최적화** : 가장 좋은 성능을 낼 수 있는 경로 선정 (인덱스 사용, 테이블 스캔 등) 
  - **컴파일 및 실행 계획 등록** : 해당 실행 계획 결과를 메모리(캐시)에 등록
  - **실행**
  
  > 💡 최적화된 결과를 바탕으로 컴파일 및 <span style="color: skyblue">실행 계획 등록 단계에서 해당 결과를 캐시에 등록</span>

<hr>

### 저장 프로시저 **정의** 단계

  <img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/0db7120b-cd1e-4df9-bbdc-a3da60e5da81">

  - **구문 분석** : 구문 오류 확인
  - **지연된 이름 확인** : 해당 개체가 존재하지 않아도 상관 X. 정의 이후 실행 시점에서 존재 여부 확인
  - **생성 권한** : 현재 사용자가 저장 프로시저를 생성할 권한이 있는지 체크
  - **시스템 테이블 등록** : 저장 프로시저의 이름 및 코드가 시스템 테이블에 등록

<br>

### 저장 프로시저 **첫 실행**

  <img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/93bec565-d9f1-4677-b421-576ab6039370">

  - 구문 분석 단계가 빠지는 것을 제외하고 일반적인 쿼리문의 수행과 동일
  - 정의 단계에서 지연된 이름 확인에서 미뤄두었던 개체 존재의 유무 확인

<br>

### 이후의 저장 프로시저 실행

  <img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/975936cf-b370-4c88-b6f8-77f41c0216c6">

  - 메모리(캐시)에 있는 것을 그대로 가져와 재사용하여 수행

<br>

## 저장 프로시저의 장단점

### 장점

- **SQL Server의 성능 향상**
  - 첫 실행 이후로는 캐시에 있는 것을 가져와 사용하므로 속도가 빨라짐
  - 여러 개의 쿼리를 한 번에 실행
- **개발 언어에 비의존적**
  - MS-SQL -> MySQL로 마이그레이션 하더라도, 호출하는 SP명은 변경이 없고, SP 안의 로직만 변경하면 가능
- **유지 보수 및 재활용**
  - 저장 프로시저의 이름을 호출하도록 설정하는 응용프로그램에서 수정 요건이 발생할 때, SQL문을 건드리지 않고 SP 파일만 수정하기 때문에 유지 보수 유리
  - 한 번 정의해놓으면, 언제든 실행이 가능하여 재활용 유리
- **보안 강화** - 권한 체계
  - 사용자들에게 데이터에 대한 제한적인 접근을 강제
  - 테이블 접근 권한이 아닌, 저장 프로시저로만의 접근 권한을 줌으로써 보안 강화
- **네트워크 부하(전송량)의 감소**
  - 클라이언트에서 서버로 쿼리의 모든 텍스트가 전송되면 네트워크 부하 발생
  - 저장 프로시저의 이름, 매개변수 등만 전송하면 되기 때문에 부하를 크게 줄임

### 단점

- **DB 확장 어려움**
  - 서비스 사용자 증가에 따라 서버 수를 늘릴 때, DB의 수를 늘리는 것이 더 어려움
- **데이터 분석의 어려움**
  - 개발된 프로시저가 여러 곳에서 사용될 경우 수정했을 때 발생하는 영향의 분석이 어려움
  - 배포, 버전 관리 등에 대한 이력 관리가 힘듬
  - 애플리케이션에서 SP를 호출하여 사용하는 경우 문제가 생겨도 이슈를 추적하기 어려움
- **특정 상황에서 낮은 처리 성능**
  - 문자, 숫자열 연산에 사용하면 오히려 c, java보다 느린 성능을 보일 수 있음

> 💡 최적화 단계에서 인덱스 사용 여부를 결정하지만, 인덱스 사용이 항상 수행 결과가 빠른 것을 보장하지 않음 <br><br> 저장 프로시저는 <span style="color: skyblue">첫 번째 수행에서만 최적화 단계가 존재</span>하여 이후 실행에서 데이터의 양이 달라져도 성능 체크를 하지 않고 실행시켜버림 -> 이를 해결하기 위해서는 저장 프로시저를 다시 컴파일 해야함