## 🗃 저장 프로시저란?

**저장 프로시저(Stored Procedure)** : DB 내부에 저장된 일련의 SQL 명령문들을 하나의 함수처럼 실행하기 위한 쿼리의 집합

> 요약💡 작성한 SQL을 옵티마이저가 해석하고 결과물을 만들어내는 데 많은 비용이 들지만, Stored Procedure로 만들어 놓으면 비용을 절약


## 🗃 일반 SQL VS 저장 프로시저

### 일반 쿼리문 작동 방식(캐시에 저장되지 않은 경우)

  <img src="https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/7b674ca1-9c91-4a46-ba1b-1cb0110502c6">

  - **구문 분석** : 구문 오류 확인
  - **개체 이름 확인** : table 유무 및 컬럼 유무 확인
  - **사용 권한** : 해당 개체에 현재 접근 중인 사용자 권한 확인
  - **최적화** : 가장 좋은 성능을 낼 수 있는 경로 선정 (인덱스 사용, 테이블 스캔 등) 
  - **컴파일 및 실행 계획 등록** : 해당 실행 계획 결과를 메모리(캐시)에 등록
  - **실행**
  
  > 💡 최적화된 결과를 바탕으로 컴파일 및 <span style="color: skyblue">실행 계획 등록 단계에서 해당 결과를 캐시에 등록</span>

  <details>
    <summary>추가 설명</summary>
    <div markdown="1">

    만약에 아래 쿼리를 실행한다고 가정하자.

    `SELECT name FROM userTbl;`
    그러면 먼저 구문 분석단계에서 구문 자체에 오류가 없는지 분석을 할 것이다. 만약 오타가 잇으면 여기서 오류가 발생되어 에러메시지를 띄울 것이다.

    다음은 개체 이름 확인 단계에서 userTbl 이라는 테이블이 현재 데이터베이스에 있는지 확인을 한다. 만약에 userTbl이 있으면 그안에 name이라는 열이 있는지를 확인할 것이다.

    그다음 사용권한 확인 단계에서 userTbl을 현재 접근중인 사용자가 권한이 있는지를 확인한다.

    다음으로 최적화 단계에서 해당 쿼리문이 가장 좋은 성능을 낼 수 있는 경로를 결정한다. 인덱스 사용여부에 따라 경로가 결정된다고 보면된다. 위의 쿼리의 경우 전체 데이터를 가져오기 때문에 아마도 테이블 스캔이나 클러스터 인덱스 스캔이 될 것이다.

    다음은 최적화된 결과를 바탕으로 컴파일 및 실행 계획 등록 단계에서 해당 실행계획 결과를 메모리(캐시)에 등록한다.

    그리고 컴파일된 결과를 실행한다. 

    </div>
  </details>

### 일반 쿼리문 작동 방식(캐시에 저장된 경우)
![img1 daumcdn](https://github.com/Fun-Fun-Study/CS-Study/assets/101235186/b4ef9a8c-2693-4053-92fc-bfa0caac2980)

만약에 캐시에 동일한 쿼리가 없다면 위의 전체 과정을 다시 반복할 것이다.

여기서 주의해야할 점은 쿼리 전체가 한글자도 틀리지 않고 같아야 한다는 것이다.


<hr>

### 저장 프로시저 **정의** 단계

  <img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/0db7120b-cd1e-4df9-bbdc-a3da60e5da81">

  - **구문 분석** : 구문 오류 확인
  - **지연된 이름 확인** : 해당 개체가 존재하지 않아도 상관 X. 정의 이후 실행 시점에서 존재 여부 확인
  - **생성 권한** : 현재 사용자가 저장 프로시저를 생성할 권한이 있는지 체크
  - **시스템 테이블 등록** : 저장 프로시저의 이름 및 코드가 시스템 테이블에 등록

<br>

### 저장 프로시저 **첫 실행**

  <img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/93bec565-d9f1-4677-b421-576ab6039370">

  - 구문 분석 단계가 빠지는 것을 제외하고 일반적인 쿼리문의 수행과 동일
  - 정의 단계에서 지연된 이름 확인에서 미뤄두었던 개체 존재의 유무 확인

<br>

### 이후의 저장 프로시저 실행

  <img src="https://github.com/Fun-Fun-Study/CS-Study/assets/73164347/975936cf-b370-4c88-b6f8-77f41c0216c6">

  - 메모리(캐시)에 있는 것을 그대로 가져와 재사용하여 수행

<br>


## 🗃 일반 쿼리문과 저장 프로시저의 차이점

```
SELECT * FROM userTbl WHERE name ='이승기';
SELECT * FROM userTbl WHERE name ='성시경';
SELECT * FROM userTbl WHERE name ='은지원';
```
해당 쿼리는 where 조건의 값만 다르다. 그런데 앞서 말한 것처럼 일반 쿼리는 글자 하나라도 다르면 다른 쿼리라 인식하기 때문에 세 쿼리 모두 다 다른 것으로 인식해버린다.

그렇기 때문에 매번 최적화와 컴파일을 다시 수행해야한다.

이걸 그냥 아래와 같은 저장 프로시저로 만들면?

```
CREATE PROC select_by_name
	@Name NVARCHAR(3)
AS
	SELECT * FROM userTbl WHERE name =@name;
```

```
EXEC select_by_name '이승기';
EXEC select_by_name '성시경';
EXEC select_by_name '은지원';
```

이렇게 하면 첫번째 이승기를 검색하는 과정에서만 최적화 및 컴파일을 수행하고 나머지는 메모리(캐시)에 있는것을 사용하게 된다. 실제로 다른 것들의 경과시간이 0ms 인지는 직접 확인해보길 바란다.

 

결국 자주 쓰는 쿼리라면 일반 쿼리를 여러 개 날리는 것보다 저정 프로시저를 쓰는게 성능적인 측면에서 효과적인 것을 확인 할 수 있다.

## 🗃 저장 프로시저의 장단점

### 장점

- **SQL Server의 성능 향상**
  - 첫 실행 이후로는 캐시에 있는 것을 가져와 사용하므로 속도가 빨라짐
  - 여러 개의 쿼리를 한 번에 실행
- **개발 언어에 비의존적**
  - MS-SQL -> MySQL로 마이그레이션 하더라도, 호출하는 SP명은 변경이 없고, SP 안의 로직만 변경하면 가능
- **유지 보수 및 재활용**
  - 저장 프로시저의 이름을 호출하도록 설정하는 응용프로그램에서 수정 요건이 발생할 때, SQL문을 건드리지 않고 SP 파일만 수정하기 때문에 유지 보수 유리
  - 한 번 정의해놓으면, 언제든 실행이 가능하여 재활용 유리
- **보안 강화** - 권한 체계
  - 사용자들에게 데이터에 대한 제한적인 접근을 강제
  - 테이블 접근 권한이 아닌, 저장 프로시저로만의 접근 권한을 줌으로써 보안 강화
- **네트워크 부하(전송량)의 감소**
  - 클라이언트에서 서버로 쿼리의 모든 텍스트가 전송되면 네트워크 부하 발생
  - 저장 프로시저의 이름, 매개변수 등만 전송하면 되기 때문에 부하를 크게 줄임

### 단점

- **DB 확장 어려움**
  - 서비스 사용자 증가에 따라 서버 수를 늘릴 때, DB의 수를 늘리는 것이 더 어려움
- **데이터 분석의 어려움**
  - 개발된 프로시저가 여러 곳에서 사용될 경우 수정했을 때 발생하는 영향의 분석이 어려움
  - 배포, 버전 관리 등에 대한 이력 관리가 힘듬
  - 애플리케이션에서 SP를 호출하여 사용하는 경우 문제가 생겨도 이슈를 추적하기 어려움
- **특정 상황에서 낮은 처리 성능**
  - 문자, 숫자열 연산에 사용하면 오히려 c, java보다 느린 성능을 보일 수 있음

> 💡 최적화 단계에서 인덱스 사용 여부를 결정하지만, 인덱스 사용이 항상 수행 결과가 빠른 것을 보장하지 않음 <br><br> 저장 프로시저는 <span style="color: skyblue">첫 번째 수행에서만 최적화 단계가 존재</span>하여 이후 실행에서 데이터의 양이 달라져도 성능 체크를 하지 않고 실행시켜버림 -> 이를 해결하기 위해서는 저장 프로시저를 다시 컴파일 해야함

읽어봐도 좋을 블로그 : https://pangtrue.tistory.com/196